\documentclass[12pt,a4paper]{article}

\usepackage{mathsx,tech,calc,mytheorems}
\usepackage{tikz}
\usepackage{cspm}
\cspMid
\def\M{\CSPMM}

\newtheorem{theorem}{Theorem}
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{note}[theorem]{Note}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{example}[theorem]{Example}
\newtheorem{corollary}[theorem]{Corollary}

%% Operational semantics
\def\trans#1{\stackrel{#1}{\rightarrow}}
\def\transd#1{\stackrel{#1}{\mapsto}}
\def\Ref{\mathrel{\it ref}}
\def\div{\mathop{\it div}}

%% Symbols
%\def\T{\mathcal{T}}
%\def\after{\circ}
\def\CSP{{\it CSP}}
\def\simo{\mathord{\sim}}
\def\project{\mathord{\|}}
\def\tick{
  \tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (0.75,.7) -- (.25,.15) -- cycle;
} 
\def\semanticRename#1{{[\![}#1{]\!]}} % semantics
\def\CSPm{CSP$_M$}
\def\banana#1{\mathord{(\!\|} #1 \mathord{\|\!)}}
\def\mset#1{\mathord{\{\!\|} #1 \mathord{\|\!\}}}
\def\Let{{\mathrm{let}\ }}
\def\unit{u}
\def\unitf{\Pi}
\def\vec#1{\overline{#1}}
\def\frho{f(\rho)} % previously f\after\rho; macro to allow backtracking.
\def\extendables{\mathop{\it extendables}}
%% Syntax
\def\rename#1{\M{[[} #1 \M{]]}\!}
\def\lArrow{\mathbin{\M{<-}}}
\def\throw#1{\mathbin{[\|#1\|\rangle}} % ]
%% Semantics 
\def\channel{\mathop{\it channel}}
\def\dtcons{\mathop{\it dtcons}}
\def\error{\mathord{\it error}}
\def\bottom{\perp}
\def\traces{\mathop{\it traces}}
\def\failures{\mathop{\it failures}}
\def\divergences{\mathop{\it divergences}}
%% Semantic functions
\def\eval{\mathop{\sf eval}}
\def\evalField{\mathop{\sf evalField}}
\def\evalFields{\mathop{\sf evalFields}}
\def\evalDollarField{\mathop{\sf eval\$Field}}
\def\evalDollarFields{\mathop{\sf eval\$Fields}}
\def\matches{\mathop{\sf matches}}
\def\bind{\mathop{\sf bind}\nolimits}
\def\bindDecl{\mathop{\sf bindDecl}}
\def\bindDecls{\mathop{\sf bindDecls}}
\def\evalStmt{\mathop{\sf evalStmt}}
\def\evalStmtSet{\mathop{\sf evalStmt^{Set}}}
\def\evalStmts{\mathop{\sf evalStmts}}
\def\evalStmtsSet{\mathop{\sf evalStmts^{Set}}}

%% \def\calc{\[ \begin{array}{@{}cl@{}} }
%% \def\endcalc{ \end{array} \]}


\title{On Data Independence}
\author{Gavin Lowe}

\sloppy

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle

\input{intro}
\input{di}
\input{evaluation}
\input{invariance}
\input{functions}
\input{main-result}
\input{denotational}

%%%%%

\section{Conclusions}

Constants.  Suppose we have a script that uses a type
\begin{cspm}
datatype T = A | B | C
\end{cspm}
and where |A| is used as a constant.
Can transform into a script 
\begin{cspm}
datatype T = B | C
datatype TT = A | Simple.T
\end{cspm}
and using |TT| in place of |T|.

%%%%%

\appendix
%\input{semantics}
%\input{invariance-app}
\input{proof}
\input{proof1}
\input{proof2}
\input{proof4} % imports: proof4-functions; proof4-processes -> proof4-prefix,
               % proof4-renaming
\input{proof3} % bindDecls
\input{proof5}
\end{document}
