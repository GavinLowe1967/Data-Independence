\section{Main result}


The following is the main result of this section.
%
\begin{prop}
\label{prop:expressions}
Suppose a script is data-independent for~$t$.  Let $T_1$ and~$T_2$ be two
instantiations of~$t$, and let $f : T_1 \fun T_2$ be surjective.  Let $\rho:
Var \fun Value$ be an environment corresponding to the script for $T_1$ (so
$\rho$ is $T_1$-invariant). 
Then:

\begin{enumerate}
\item\label{item:matches} Let $pat$ be a pattern, and $v$ a value; then
\begin{eqnarray*}
  \matches \rho~ pat~v & \iff & \matches (f(\rho)) ~ pat~(f(v)).
\end{eqnarray*}

\item\label{item:bind}
Let $pat$ be a pattern, and $v$ a value; then
\begin{eqnarray*}
f  (\bind_0 \rho~pat~v) &  = & \bind_0 (f(\rho))~pat~(f(v)),
\end{eqnarray*}
and hence
\begin{eqnarray*}
f  (\bind \rho~pat~v) & = & \bind (f(\rho))~pat~(f(v)).
\end{eqnarray*}

\item\label{item:bindDecls} Suppose $decls$ is a list of declarations of
  values, channels and datatypes, with disjoint names.  Then
  \begin{eqnarray*}
  f (\bindDecl \rho~decl) & = & \bindDecl (f(\rho))~decl.
  \end{eqnarray*}
  and hence
  \begin{eqnarray*}
  f (\bindDecls \rho~decls) & = & \bindDecls (f(\rho))~decls.
  \end{eqnarray*}
%
Further, if $decl$ represents a function declaration, then $\bindDecl
\rho~decl$ binds the relevant name to a function~$g$ that respects~$f$.  Hence
the same is true for each declaration in~$decls$. 

%%%%%

\item\label{item:eval} For every expression~$e$ in the script,
\begin{eqnarray*}
f(\eval \rho ~ e) & = \eval (f(\rho)) ~e .
\end{eqnarray*}

Further, if $\eval \rho ~ e$ gives a function~$g$, then $g$ respects~$f$. 

\item\label{item:evalStmts} For every sequence statement~$stmt$, and list
  of sequence statements~$stmts$, and every environment~$\rho$:
\begin{eqnarray*}
f (\evalStmt \rho ~ stmts) & = & \evalStmt (f(\rho))~stmt, \\
f (\evalStmts \rho ~ stmts) & = & \evalStmts (f(\rho))~stmts.
\end{eqnarray*}
%
And similarly for set statements:
%
\begin{eqnarray*}
f (\evalStmtSet \rho ~ stmt) & = & \evalStmtSet (f(\rho))~stmt, \\
f (\evalStmtsSet \rho ~ stmts) & = & \evalStmtsSet (f(\rho))~stmts.
\end{eqnarray*}
%
%% \framebox{***} As sets, but not as sequences. 

%% \item \label{item:evalStmts}
%% Under some circumstances, the previous also holds for sequences and
%% multisets. 
\end{enumerate}

\end{prop}
%%  for
%% every expression~$e$ in the script
%% \begin{eqnarray*}
%% f(\eval \rho ~ e) & = \eval (f(\rho)) e .
%% \end{eqnarray*}
%
The proof is in Appendix~\ref{sec:proof}.

