\section{Main result}
\label{sec:main-result}

We are now ready to present the main result.
%
\begin{prop}
\label{prop:expressions}
Suppose a script is data-independent for~|T|.  Let $T_1$ and~$T_2$ be two
instantiations of~|T|, and let $f : T_1 \fun T_2$ be surjective.  Let $\rho:
Name \fun Value$ be an environment corresponding to the script for $T_1$ (so
$\rho$ is $T_1$-invariant, by Corollary~\ref{cor:invariant}).  
%
\begin{enumerate}
\item\label{item:matches} Let $pat$ be a pattern, and $v$ a value; then
\begin{eqnarray*}
  \matches \rho~ pat~v & \iff & \matches (f(\rho)) ~ pat~(f(v)).
\end{eqnarray*}

\item\label{item:bind}
Let $pat$ be a pattern, and $v$ a value; then
\begin{eqnarray*}
f  (\bind_0 \rho~pat~v) &  = & \bind_0 (f(\rho))~pat~(f(v)),
\end{eqnarray*}
and hence
\begin{eqnarray*}
f  (\bind \rho~pat~v) & = & \bind (f(\rho))~pat~(f(v)).
\end{eqnarray*}

%%%%%

\item\label{item:eval} For every expression~$e$ in the script,
\begin{eqnarray*}
f(\eval \rho ~ e) & = \eval (f(\rho)) ~e .
\end{eqnarray*}

Further, if $\eval \rho ~ e$ gives a function~$g$, then $g$ respects~$f$. 

%%%%%

\item\label{item:bindDecls} Suppose $decl$ is a declaration of a value,
  channel or datatype, and $decls$ is a list of such declarations with
  disjoint names.  Then
  \begin{eqnarray*}
  f (\bindDecl \rho~decl) & = & \bindDecl (f(\rho))~decl, \\
  %% \end{eqnarray*}
  %% and hence
  %% \begin{eqnarray*}
  f (\bindDecls \rho~decls) & = & \bindDecls (f(\rho))~decls.
  \end{eqnarray*}
%
Further, if a name is bound to a function~$g$, then $g$ respects~$f$. 
%% if $decl$ represents a function declaration, then $\bindDecl \rho~decl$
%% binds the relevant name to a function~$g$ that respects~$f$.  Hence the
%% same is true for each function declaration bound by $\bindDecls
%% \rho~decls$.

%%%%%

\item\label{item:evalStmts} For every sequence statement~$stmt$, and list
  of sequence statements~$stmts$, and every environment~$\rho$:
\begin{eqnarray*}
f (\evalStmt \rho ~ stmts) & = & \evalStmt (f(\rho))~stmt, \\
f (\evalStmts \rho ~ stmts) & = & \evalStmts (f(\rho))~stmts.
\end{eqnarray*}
%
And similarly for set statements:
%
\begin{eqnarray*}
f (\evalStmtSet \rho ~ stmt) & = & \evalStmtSet (f(\rho))~stmt, \\
f (\evalStmtsSet \rho ~ stmts) & = & \evalStmtsSet (f(\rho))~stmts.
\end{eqnarray*}
\end{enumerate}
\end{prop}
%
The proof is in Appendix~\ref{sec:proof}: it proceeds by a (rather long)
structural induction over \CSPm\ syntax.  

