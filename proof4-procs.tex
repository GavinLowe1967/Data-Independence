%% \subsubsection{Processes}
%% \label{sec:processes}

%We now consider process expressions.

\subsubsection{Basic processes}  
\label{sec:basic-procs}

The cases for $STOP$, $SKIP$, and $DIV$ are all trivial.

The process-creating functions |RUN| and |CHAOS| satisfy the conditions of
Lemma~\ref{lem:built-in-functions}, and so can be dealt with as in
Section~\ref{sssec:function-decl}. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{proof4-prefix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Non-replicated sequential operators.}
\label{sec:sequential-procs}

We now consider non-replicated sequential operators.  

\paragraph{Binary sequential operators.}

We start with external choice.
%
Below we write $\extchoice$ for a semantic operator: ``${P \extchoice Q}$''
represents an external choice between~$P$ and~$Q$, each of which is an LTS\@.
We show that
%
\begin{eqnarray*}
f(P \extchoice Q) & = & f(P) \extchoice f(Q).
\end{eqnarray*}
%
For every transition $P \trans{e} P'$, the initial state of each of the above
processes has a transition labelled $f(e)$ to~$f(P')$; and similarly for
transitions of~$Q$.

We then have the following (for syntactic expressions~$P$ and~$Q$; in the
first and last lines, ``\CSPM{[]}'' is syntax; in other lines, it is the
semantic operator):
%
\begin{calc}
& f(\eval \rho ~ (P \; \M{[]} Q) \\
= & f((\eval \rho~P) \extchoice (\eval \rho~Q)) \\
= & \com{above result} \\
& f(\eval \rho~P) \extchoice f(\eval \rho~Q) \\
= & \com{inductive hypothesis} \\
& (\eval (f(\rho))~P) \extchoice (\eval (f(\rho))~Q) \\
= & \eval (f(\rho)) (P \; \M{[]} Q).
\end{calc}

The proofs for the binary operators nondeterministic choice (\CSPM{_ \|~\|
_}), sliding choice (\CSPM{_ [> _}), interrupt (\CSPM{_ /\\ _}), and
sequential composition (\CSPM{_ ; _}) are very similar.

For the exception operator (\CSPM{_ [\| E \|> _}), recall that we assume that
|E| is invariant (item~\ref{item:di-invariant} of
Definition~\ref{defn:data-independent}).  Hence $\eval \rho~E$ is
$T_1$-invariant, by Lemma~\ref{lem:invariant}.
%  
We write $\_ \throw{A} \_$ for the corresponding semantic operator.  We show
that if $A$ is $T_1$-invariant then
\begin{eqnarray*}
f(P \throw{A} Q) & = & f(P) \throw{f(A)} f(Q).
\end{eqnarray*}
%
On the left-hand side, every transition of~$P$ on an event from~$A$ is replace
by a transition to the initial state of~$Q$, and then all events are renamed
by~$f$.  On the right-hand side, the events are renamed first, and then every
transition from $f(P)$ on an event from~$f(e) \in f(A)$ is replaced by a
transition to the initial state of~$f(Q)$.  But if $f(e) \in f(A)$ then $e \in
A$, by Lemma~\ref{lem:T-invariant-inclusion}, so there is a corresponding
transition on the left-hand side.  The rest of the proof is then as for
external choice.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{proof4-renaming}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Other sequential operators.} 

For hiding, note that if $A$ is $T_1$-invariant, then
\begin{eqnarray*}
f(P \hide A) & = & f(P) \hide f(A).
\end{eqnarray*}
%
On the right-hand side, an event $e$ of~$P$ is hidden if $f(e) \in f(A)$; but
then $e \in A$, by Lemma~\ref{lem:T-invariant-inclusion}, so the same event is
hidden on the left-hand side.  The rest of the proof is then as for external
choice.

The case for projection is almost identical to that for hiding. 

The result holds for structural operators (local declarations and |if|
statements) as in Section~\ref{sec:structural}.

A guarded process $g ~\M{\&}~ P$ is equivalent to $\M{if}~ g ~ \M{then}~
P ~ \M{else STOP}$.  The result follows from the result for |if| statements.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Binary Parallel operators.}
\label{sec:parallel}

We now consider the binary parallel operators.  We start with the generalised
parallel operator $\_ \;\M{[\|} e_A \M{\|]} \; \_$\,.  Recall that we assume
that the expression~$e_A$ defining the synchronisation set is invariant, and
hence the value of that set is $T_1$-invariant.

We write $\_ \parallel[A] \_$ for a semantic operator that forms the parallel
composition of LTSs, synchronising on events from~$A$.  
Recall that we assume
that the identifiers bound by the two components of the parallel composition
are disjoint; this means that we can restrict a ``global'' environment to the
identifiers of each component, or form the union of the environments of the
two components.  For example, if $(P, \rho_P) \trans{e} (P', \rho_P')$ and
$(Q, \rho_Q) \trans{e} (Q',
\rho_Q')$ with $e \in A$, and $\rho_P$ and~$\rho_Q$ agree on common
identifiers, then $(P \parallel[A] Q, \rho_P \union \rho_Q) \trans{e} (P'
\parallel[A] Q', \rho_P' \union \rho_Q')$: the resulting environments
$\rho_P'$ and $\rho_Q'$ agree on common identifiers, so their union makes
sense.

We show that, assuming $A$ is $T_1$-invariant:
%
\begin{eqnarray}
\label{eqn:parallel-dist}
f((P,\rho_P) \parallel[A] (Q,\rho_Q)) & = & 
  f(P,\rho_P) \parallel[f(A)] f(Q,\rho_Q).
\end{eqnarray}
%
The tricky case is as follows.  Consider a transition of the right-hand side
corresponding to a synchronisation on event~$e \in f(A)$.  This must
correspond to transitions 
\[
(P,\rho_P) \trans{e_P} (P',\rho_P') \quad\mbox{and}\quad
(Q,\rho_Q) \trans{e_Q} (Q',\rho_Q') \quad
\mbox{with}\quad f(e_P) = f(e_Q) = e.
\]
The subsequent state is 
\[
f(P',\rho_P') \parallel[f(A)] f(Q',\rho_Q') = 
  (P',f(\rho_P')) \parallel[f(A)] (Q',f(\rho_Q')).
\]
If $e_P \ne e_Q$, then consider the first field in which they differ; say $e_p
= c.\vec{u}.v_P.\vec{w_P}$ and $e_Q = c.\vec{u}.v_Q.\vec{w_Q}$ with $v_P \ne
v_Q$ but $f(v_P) = f(v_Q)$.
%
Then by item~\ref{item:sync} of Definition~\ref{defn:data-independent}, one of
the processes must be willing to accept an arbitrary value in this position;
without loss of generality, suppose this is~$P$, so $P$ can also perform $e_P'
= c.\vec{u}.v_Q.\vec{w_P}$.  If the transition binds $x$ to this field in
$P$'s environment, then this corresponds to the transition
$(P,\rho_P) \trans{e_P'} (P,\rho_P'')$ where $\rho_P''
= \rho_P' \oplus \set{x \mapsto v_Q}$.  Note that $f(e_P') = e$ and
$f(\rho_P'') = f(\rho_P')$.
%
Continuing in this way, we obtain transitions
\[
\begin{array}{c}
(P,\rho_P) \trans{e'} (P',\hat\rho_P) \quad\mbox{and}\quad
(Q,\rho_Q) \trans{e'} (Q',\hat\rho_Q) \\
\mbox{with}\quad f(e')  = e, \quad 
f(\hat\rho_P) = f(\rho_P'), \quad f(\hat\rho_Q) = f(\rho_Q').
\end{array}
\]
Also, note that $f(e') = e \in f(A)$, so $e' \in A$, by
Lemma~\ref{lem:T-invariant-inclusion}, since $A$ is $T_1$-invariant.
%
Hence, in the left-hand side of (\ref{eqn:parallel-dist}), the two
components can synchronise on~$e'$, giving a transition on $f(e') = e$, and
producing state 
\[
f( (P',\hat\rho_P) \parallel[A] (Q',\hat\rho_Q) ) .
\]
This matches the original transition of the right-hand side.

Other cases ---that every synchronisation of the left-hand side is matched by
a synchronisation of the right-hand side, and that non-synchronisation
transitions match--- can be proved in a similar but more straightforward way.

The proof then proceeds as for other binary operators.  

The cases of the alphabetised parallel ($\M{[} A\, \M{\|\|}\, B \M{]} $),
interleaving (\CSPM{\|\|\|}), synchronising external choice
(\CSPM{[+}\,$A$\,\CSPM{+]}) and synchronising interrupt
(\CSPM{/+}\,A\,\CSPM{+\\}) operators are similar; recall that it is assumed
that the expressions that define the alphabets are invariant, and hence the
values of those alphabets are $T_1$-invariant.

The case of  link parallel follows from earlier cases, since any instance can
be rewritten using a combination of renaming, generalised parallel, and
hiding: the conditions placed on use of link parallel
(clause~\ref{item:di-renaming} of Definition~\ref{defn:data-independent}) are
enough to imply the requirements for use of those other operators.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Replicated operators}  
\label{sec:replicated}

We now consider replicated operators.  We start with external choice.  Below
we write $\Extchoice$ for a semantic operator: $\Extchoice S$ represents an
external choice over the set of processes in~$S$, each of which is an LTS\@.
We show
%
\begin{eqnarray*}
f(\Extchoice S) & = & \Extchoice \set{f(P) \| P \in S}.
\end{eqnarray*}
%
For every $P \in S$, and for every transition $P \trans{e} Q$, the initial
state of each of the above processes has a transition labelled with $f(e)$ to
$f(Q)$.

We then have the following (the external choices in the first and last line
are syntax; the other instances are semantic):
\begin{calc}
& f(\eval \rho~ (\M{**[]} stmts \spot P)) \\
= & f(\Extchoice \set{\eval \rho'~ P \| \rho' \in \evalStmtsSet \rho~stmts}) \\
= & \com{above result} \\
  & \Extchoice \set{f(\eval \rho' ~P) \| \rho' \in \evalStmtsSet \rho~stmts} \\
= & \com{inductive hypothesis for~$P$} \\
  & \Extchoice \set{\eval (f(\rho'))~P \| 
      \rho' \in \evalStmtsSet \rho~stmts} \\
= & \com{letting $\rho'' = f(\rho')$} \\
  & \Extchoice \set{\eval \rho''~P \| 
      \rho'' \in f(\evalStmtsSet \rho~stmts)} \\
= & \com{inductive hypothesis, clause \ref{item:evalStmts}} \\
  & \Extchoice \set{\eval \rho''~P \| 
      \rho'' \in \evalStmtsSet (f(\rho))~stmts} \\
= & \eval (f(\rho))~ (\M{**[]} stmts \spot P).
\end{calc}

%%%%%

The case for a replicated nondeterministic choice is similar.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Consider now a replicated interleaving $\M{**\|\|\|} ~ stmts ~ \M{@} ~ P$.
% Recall that the indexing statements~$stmts$ are independent of~|T|.
We write $\Interleave$ for a semantic interleaving operator, which takes a
multiset\footnote{We write a multiset as ``$\mset{\ldots}$''.} of processes as
an argument.  We have that
%
\begin{eqnarray}
\label{eqn:replicated-interleave}
f(\Interleave S) & = & \Interleave \mset{f(P) \| P \in S}.
\end{eqnarray}
%
This follows from the corresponding equation $f(P \interleave Q) =
f(P) \interleave f(Q)$ for binary interleaving, and the fact that the replicated
interleaving can be rewritten using binary interleaving.  It is important here
that we are using a \emph{multiset}, so the two sides
of~(\ref{eqn:replicated-interleave}) have the same number of processes, even if
$f$ unifies two elements of~$S$: this matches the semantics of~\CSPm, which
produces a set of environments from $stmts$, and then from each such
environment produces a process (possibly with repetitions).

Recall that the indexing statements~$stmts$ are independent of~|T|.  Suppose
$\evalStmtsSet~\rho~stmts$ includes an environment $\rho \oplus \rho'$ where
$\rho'$ captures the bindings in~$stmts$, and so is independent of~$f$; 
then $f(\rho \oplus \rho') = f(\rho) \oplus \rho'$.  
%%  ; then $f(\evalStmts \rho~stmts)$ will produce a corresponding environment
%%  $f(\rho) \oplus \rho'$; and vice versa.
This means that the sets $\evalStmtsSet~\rho~stmts$ and
$f(\evalStmtsSet \rho~stmts)$ have the same cardinality: the application
of~$f$ does not unify two different bindings corresponding to $stmts$.

We calculate as follows.
%
\begin{calc}
& f(\eval \rho (\M{**\|\|\|} ~ stmts~ \M{@} ~ P)) \\
= & f( \Interleave \mset{ \eval \rho' ~ P \|
          \rho' \in \evalStmtsSet \rho~stmts} ) \\
= & \com{equation (\ref{eqn:replicated-interleave})} \\
& \Interleave \mset{ f(\eval \rho'~P) \| 
     \rho' \in \evalStmtsSet \rho~stmts}  \\
= & \com{inductive hypothesis} \\
& \Interleave \mset{ \eval (f(\rho'))~P \| 
    \rho' \in \evalStmtsSet \rho~stmts}  \\
= & \com{letting $\rho'' = f(\rho')$; above observation about cardinality} \\
& \Interleave \mset{ \eval \rho''~P \| 
    \rho'' \in f(\evalStmtsSet \rho~stmts)}  \\
= & \com{inductive hypothesis, clause~\ref{item:evalStmts}} \\
& \Interleave \mset{ \eval \rho''~P \| 
    \rho'' \in \evalStmtsSet (f(\rho))~stmts}  \\
= & \eval (f(\rho))~(\M{**\|\|\|} ~ stmts~ \M{@}~ P).
\end{calc}

%%%%%%%%%%

The cases for other replicated operators are very similar.  Recall that we
assume that each of the alphabets on parallel operators is defined by an
invariant expression, and so evaluates to a $T_1$-invariant set.  In each case,
we use a result similar to equation~(\ref{eqn:replicated-interleave}) to
distribute~$f$ through the corresponding semantic operator.  For replicated
sequential composition and link parallel, the statements are evaluated using
$\evalStmts$ to produce a sequence, rather than a set. 

% Alphabetised parallel, generalised parallel, link parallel, sequential
% composition. 

%%%%%%%%%%
