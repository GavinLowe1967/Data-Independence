\section{Semantics}
\label{sec:semantics}

Something akin to Appendix~A from the symmetry reduction TR.  This maybe lives
in the main body. 

The semantics is defined using the following functions:
%
\begin{itemize}
\item $\eval : Env \fun Expr \pfun Value$ such that $\eval \rho~e$ gives the
  value of expression~$e$ in environment~$\rho$.

\item $\matches : Env \fun Pat \fun Value \fun Bool$ such that
  $\matches \rho~pat ~ v$ tests whether pattern~$pat$ can be matches by
  value~$v$.

\item $\bind_0, \bind : Env \fun Pat \fun Value \pfun Env$ such that
  $\bind_0 \rho~pat~v$ gives the updates to the environment by binding
  pattern~$pat$ to value~$v$, and is defined when $\matches \rho~ pat~v$; and 
  $\bind \rho~pat~v$ gives the result of those updates, i.e.
  \begin{eqnarray*}
  \bind \rho~pat~v & = & \rho \oplus \bind_0 \rho~pat~v.
  \end{eqnarray*}
% Do we need $\rho$ for $bind_0$?  Yes, we do: we need to know whether an
% identifier represents a datatype constructor or a channel. 

\item $\bindDecls : Env \fun Decl^* \pfun Env$ such that
  $\bindDecls \rho~decls$, updates $\rho$ corresponding to the list of
  declarations $decls$, assuming that all names bound by the declarations are
  distinct, and that each pattern matches the corresponding expression.

\item $\evalStmts : Env \fun Stmt^* \fun Env^*$ (where $Stmt$ contains
  generators or predicates in set or sequence comprehensions) such that
  $\evalStmts \rho~stmts$ gives the sequence of environments resulting from
  evaluating the statements~$stmts$.  (In some circumstances, this sequence of
  environments is converted into a multiset; we elide this conversion
  below.)

\item $\evalStmtsSet : Env \fun Stmt^* \fun \power(Env)$ such that
  $\evalStmtsSet \rho~stmts$ gives the set of environments resulting from
  evaluating the statements~$stmts$.
\end{itemize}
