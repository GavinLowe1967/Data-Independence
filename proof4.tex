\subsection{Expressions}

We show that for every expression~$e$ in the script,
\begin{eqnarray*}
f(\eval \rho ~ e) & = \eval (f \after \rho) e .
\end{eqnarray*}

\framebox{\ldots}

%% Note:
%% \begin{eqnarray*}
%% \eval \rho ~(g(e)) & = & (\eval \rho ~g) (\eval \rho~ e) \\
%% \eval \rho ~(\lambda x \spot e) & = & 
%%   \lambda z \spot \eval (\rho \oplus \set{x \mapsto z})~ e.
%% \end{eqnarray*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Atomic values}

\paragraph{Names.}

Consider a name~$x$ bound by the environments, other than a datatype
constructor or channel name.  Then
\[
f(\eval \rho~x) = f(\rho~x) = \eval (f\after\rho)~x.
\]

Not consider the name~$d$ of a datatype constructor (so both $\rho$ and
$f\after\rho$ map $c$ to a $\dtcons$ value).  Necessarily, $d$ is not a member
of~$t$, given our assumption about values from~$t$ not appearing in the
script.  Note that $d$ evaluates to itself, regardless of the environment.
Hence
\[
f(\eval \rho~d) = f(d) = d = \eval (f\after\rho)~d.
\]
Note that the middle step would fail to hold for a member of~$t$: this
justifies our assumption about such values not appearing in the script. 

The case of the name of a channel is identical to the previous case. 



%% Now consider the name~$c$ of a channel (so both $\rho$ and $f\after\rho$ map
%% $c$ to a $\channel$ value).  In this case, $c$ evaluates to itself,
%% regardless of the environment.  Hence
%% \[
%% f(\eval \rho~c) = f(c) = c = \eval (f\after\rho)~c.
%% \]

%% I don't think we need this -- it's dealt with in bindDecls
%
%% Now consider the name $d$ of a datatype with constructors $C_1,\ldots,C_k$.
%% If a constructor $C$ maps to a value $\dtcons S$ in an environment, we write
%% $C.S$ for the corresponding set of extensions, $\set{C.x \| c \in S}$.
%% %
%% \begin{calc}
%% & f(\eval \rho~d) \\
%% = & f\Big(\Union\nolimits_{i \in \set{1,\ldots,k}}  
%%        \Let \dtcons S_i = \rho(C_i) \In S_i \Big) \\ 
%% = & \Union\nolimits_{i \in \set{1,\ldots,k}} 
%%        \Let \dtcons S_i = \rho(C_i) \In f(S_i) \\
%% = & \Union\nolimits_{i \in \set{1,\ldots,k}} 
%%       \Let \dtcons S_i' = f(\rho(C_i)) \In S_i \\
%% = & \eval (f\after\rho)~d.
%% \end{calc}

Names of types *** I don't think this is necessary as a separate case -- dealt
with in bindDecls.

|Events|



%%%%%

\paragraph{Basic values.}

For a basic value~$v$ (an integers, boolean or character):
\[
f(\eval \rho~v) = f(v) = v = \eval(f\after\rho)~v,
\]
since $v$ is independent of~$t$. 

%%%%%%%%%%

\paragraph{\ldots}



|Events|


\subsubsection{Composite values}

Case $e_1 . e_2$.
%
\begin{calc}
& f(\eval \rho ~(e_1.e_2)) \\
 = & f(\eval \rho~e_1. \eval \rho~e_2) \\
 = & f(\eval \rho~e_1) . f(\eval \rho~e_2) \\
 = & \com{inductive hypothesis} \\
  & \eval (f\after\rho)~e_1 . \eval (f\after\rho)~e_2 \\
 = & \eval (f\after\rho) (e_1.e_2).
\end{calc}

The case for tuples is very similar.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Structural operators}

The case for local declarations is as follows.
%
\begin{calc}
& f(\eval \rho~(\M{let}~decls~\M{within}~e)) \\
= & f(\Let \rho' = \bindDecls \rho~decls \In \eval \rho'~e) \\
= & \Let \rho' = \bindDecls \rho~decls \In f(\eval \rho'~e) \\
= & \com{inductive hypothesis} \\
 &  \Let \rho' = \bindDecls \rho~decls \In \eval (f\after\rho')~e \\
= & \com{letting $\rho'' = f\after\rho'$} \\
& \Let \rho'' = f \after \bindDecls \rho~decls \In \eval \rho''~e \\
= & \com{inductive hypothesis, clause~\ref{item:bindDecls}} \\
& \Let \rho'' = \bindDecls (f\after\rho)~decls \In \eval \rho''~e \\
= & \eval (f\after\rho)~(\M{let}~decls~\M{within}~e).
\end{calc}

The case for if statements is as follows.
%
\begin{calc}
& f(\eval \rho~(\M{if}~b~\M{then}~e_1~\M{else}~e_2)) \\
= & f(\If \eval \rho~b \Then \eval \rho~e_1 \Else \eval \rho~e_2) \\
= & \com{boolean values invariant under~$f$} \\
 & \If f(\eval \rho~b) \Then f(\eval \rho~e_1) \Else f(\eval \rho~e_2) \\
= & \com{inductive hypothesis} \\
 & \If \eval~(f\after\rho)~b \Then \eval (f\after\rho)~e_1) 
    \Else \eval(f\after\rho)~e_2 \\
= & \eval (f\after\rho) (\M{if}~b~\M{then}~e_1~\M{else}~e_2).
\end{calc}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{proof4-functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \paragraph{Function application}

%% \begin{calc}
%% & f(\eval \rho~(g(e))) \\
%% = & f((\eval \rho~g)~ (\eval \rho~e)) \\
%% = & f(\eval \rho~g)~ (f(\eval \rho~e)) \\
%% = & \eval (f\after\rho)~g ~(\eval (f\after\rho)~e) \\
%% = & \eval (f\after\rho) (g(e)).
%% \end{calc}

\subsubsection{Collections}
\label{sec:collections}

Lists

Sets, mappings

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Other stuff.}

Case |extensions|, |productions|,


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{proof4-procs}
