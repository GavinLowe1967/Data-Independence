\subsection{Expressions}

We show that for every expression~$e$ in the script,
\begin{eqnarray*}
f(\eval \rho ~ e) & = \eval (f(\rho)) e .
\end{eqnarray*}

\framebox{\ldots}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Atomic values}

\paragraph{Names.}

Consider a name~$x$ bound by the environments, other than a datatype
constructor or channel name.  Then
\[
f(\eval \rho~x) = f(\rho~x) = \eval (f(\rho))~x.
\]

Not consider the name~$d$ of a datatype constructor (so both $\rho$ and
$f(\rho)$ map $c$ to a $\dtcons$ value).  Necessarily, $d$ is not a member
of~$t$, given our assumption about values from~$t$ not appearing in the
script.  Note that $d$ evaluates to itself, regardless of the environment.
Hence
\[
f(\eval \rho~d) = f(d) = d = \eval (f(\rho))~d.
\]
Note that the middle step would fail to hold for a member of~$t$: this
justifies our assumption about such values not appearing in the script. 

The case of the name of a channel is identical to the previous case. 

Names of types *** I don't think this is necessary as a separate case -- dealt
with in bindDecls.


%%%%%

\paragraph{Basic values.}

For a basic value~$v$ (an integers, boolean or character):
\[
f(\eval \rho~v) = f(v) = v = \eval(f(\rho))~v,
\]
since $v$ is independent of~$t$. 

%%%%%%%%%%

\paragraph{\ldots}


|Events|


\subsubsection{Composite values}

Case $e_1 . e_2$.
%
\begin{calc}
& f(\eval \rho ~(e_1.e_2)) \\
 = & f(\eval \rho~e_1. \eval \rho~e_2) \\
 = & f(\eval \rho~e_1) . f(\eval \rho~e_2) \\
 = & \com{inductive hypothesis} \\
  & \eval (f(\rho))~e_1 . \eval (f(\rho))~e_2 \\
 = & \eval (f(\rho)) (e_1.e_2).
\end{calc}

The case for tuples is very similar.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Structural operators}

The case for local declarations is as follows.
%
\begin{calc}
& f(\eval \rho~(\M{let}~decls~\M{within}~e)) \\
= & f(\Let \rho' = \bindDecls \rho~decls \In \eval \rho'~e) \\
= & \Let \rho' = \bindDecls \rho~decls \In f(\eval \rho'~e) \\
= & \com{inductive hypothesis} \\
 &  \Let \rho' = \bindDecls \rho~decls \In \eval (f(\rho'))~e \\
= & \com{letting $\rho'' = f(\rho')$} \\
& \Let \rho'' = f (\bindDecls \rho~decls \In \eval \rho''~e) \\
= & \com{inductive hypothesis, clause~\ref{item:bindDecls}} \\
& \Let \rho'' = \bindDecls (f(\rho))~decls \In \eval \rho''~e \\
= & \eval (f(\rho))~(\M{let}~decls~\M{within}~e).
\end{calc}

The case for if statements is as follows.
%
\begin{calc}
& f(\eval \rho~(\M{if}~b~\M{then}~e_1~\M{else}~e_2)) \\
= & f(\If \eval \rho~b \Then \eval \rho~e_1 \Else \eval \rho~e_2) \\
= & \com{boolean values invariant under~$f$} \\
 & \If f(\eval \rho~b) \Then f(\eval \rho~e_1) \Else f(\eval \rho~e_2) \\
= & \com{inductive hypothesis} \\
 & \If \eval~(f(\rho))~b \Then \eval (f(\rho))~e_1) 
    \Else \eval(f(\rho))~e_2 \\
= & \eval (f(\rho)) (\M{if}~b~\M{then}~e_1~\M{else}~e_2).
\end{calc}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{proof4-functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection{Collections}
\label{sec:collections}

\begin{itemize}
\item
Case of a set comprehension. Below, the set comprehensions in the first and
last line are syntax, and the other set comprehensions are semantics. 
% 
\begin{calc}
& f(\eval \rho ~ \set{ e \| stmts }) \\
= & f(\set{ \eval \rho'~e \| \rho' \in \evalStmtsSet \rho~stmts }) \\
= & \set{ f(\eval \rho'~e) \| \rho' \in \evalStmtsSet \rho~stmts } \\
= & \com{inductive hypothesis} \\
  & \set{ \eval (f(\rho'))~e) \| \rho' \in \evalStmtsSet \rho~stmts } \\
= & \com{letting $\rho'' = f(\rho')$} \\ 
  & \set{ \eval \rho''~e) \| \rho'' \in f(\evalStmtsSet \rho~stmts) } \\
= & \com{clause \ref{item:evalStmts}} \\
  & \set{ \eval \rho''~e) \| \rho'' \in \evalStmtsSet (f(\rho))~stmts } \\
= & \eval (f(\rho)) ~ \set{e \| stmts}.
\end{calc}

\item The case for  a sequence comprehension $\M{<}\, e \| stmts \,\M{>}$ is
very to that for a set comprehension, except $stmts$ are evaluated using
$\evalStmts$, which produces a sequence of environments.

\item The cases for a set $\{e_1, \ldots, e_n\}$, ranged integer set
$\set{e .. e'}$ (where $e$ and~$e'$ evaluate to integers), infinite integer
set $\set{ e .. }$, sequence $\M{<} e_1, \ldots, e_n \M{>}$, ranged integer
sequence $\M< e .. e' \M>$, and infinite integer equence $\M< e .. \M>$, are
straightforward.

\item The case for a map $(\| k_1 => v_1, ..., k_n => v_n \|)$ is also
straightforward: recall that the domain type of a map mucs be independent
of~$t$, so eack $k_i$ evaluates to a value that is invariant under~$f$. 

\item extensions sets \framebox{...}


\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Other stuff.}

Case |extensions|, |productions|,


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{proof4-procs}
