

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Main proposition}

\begin{prop}
\label{prop:expressions-1}
Suppose a script is data-independent for~$t$.  Let $T_1$ and~$T_2$ be two
instantiations of~$t$, let $\rho: Var \fun T_1$ be an environment
corresponding to the script (so $\rho$ is $T_1$-invariant), and let $f : T_1
\fun T_2$ be surjective.  Then:
\begin{enumerate}
\item\label{item:matches} Let $pat$ be a pattern, and $v$ a value; then
\begin{eqnarray*}
  \matches \rho~ pat~v & \iff & \matches (f\after\rho) ~ pat~(f(v)).
\end{eqnarray*}

\item\label{item:bind}
Let $pat$ be a pattern, and $v$ a value; then
\begin{eqnarray*}
f \after (\bind_0 \rho~pat~v) &  = & \bind_0 (f\after\rho)~pat~(f(v)),
\end{eqnarray*}
and hence
\begin{eqnarray*}
f \after (\bind \rho~pat~v) & = & \bind (f\after\rho)~pat~(f(v)).
\end{eqnarray*}

\item\label{item:bindDecls} Suppose $decls$ is a list of declarations of
  values, channels and datatypes, with disjoint names.  Then
  \begin{eqnarray*}
  f \after \bindDecls \rho~decls & = & \bindDecls (f \after \rho)~decls.
  \end{eqnarray*}

Also every function produced respects~$f$. 

%% Further, if $\rho$ respects~$f$ then $\bindDecls \rho~decls$ respects~$f$.
%% Hence the environment formed from evaluating the top level
%% declarations respects~$f$. \framebox{***}.

%
  %% Hence, letting $\rho_1$ be the environment formed from evaluating the
  %% top-level declarations, we have that

  %% \framebox{Hence $t$-closed}

  %% Hence, letting $\rho_1$ be the environment formed from evaluating the
  %% top-level declarations, we have that $f(\rho_1(x)) = \rho_1(x)$ for each
  %% name~$x$ bound at the top level.  

  %% In particular, this shows that the set of values associated with each
  %% channel or datatype name is closed under~$\pi$; i.e.~$\rho_1$
  %% respects~$\pi$.


\item\label{item:eval} For every expression~$e$ in the script,
\begin{eqnarray*}
f(\eval \rho ~ e) & = \eval (f \after \rho) ~e .
\end{eqnarray*}

\item\label{item:evalStmtsSet}
For every sequence~$stmts$ of statements (generators or qualifiers), and every
environment~$\rho$\,  
\begin{eqnarray*}
f (\evalStmtsSet \rho ~ stmts) & = & \evalStmtsSet (f\after\rho)~stmts.
\end{eqnarray*}
%
\framebox{***} As sets, but not as sequences. 

\item \label{item:evalStmts}
Under some circumstances, the previous also holds for sequences and
multisets. 
\begin{eqnarray*}
f (\evalStmts \rho ~ stmts) & = & \evalStmts (f\after\rho)~stmts.
\end{eqnarray*}

\end{enumerate}
\end{prop}

%%%%%%%%%%

The proof is by induction over the syntax of \CSPm.  It is split over the
following subsections.  We will refer to the above clauses as clause~1 to
clause~\ref{item:evalStmts}. 

%%%%%%%%%%
