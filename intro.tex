\section{Introduction}

This note seeks an alternative characterisation of data independence.

Write |T| (in sans serif font) for the name used for the type in the script (a
piece of syntax).  We write $T$, $T_1$, $T_2$, etc.\ (in maths font) for
instantiations of~|T| (sets of values, i.e.~semantics). 

We consider a \CSPm\ script that is data independent in a type~|T|, including
no equality tests on values of type~|T|.  We make these requirements more
precise below.

Let $P[\M T]$ be a family of processes parameterised by the type~|T|.  We
consider instantiating the type parameter by two concrete types~$T_1$ and
$T_2$; we write the resulting processes as $P[T_1]$ and $P[T_2]$.  Let $f: T_1
\fun T_2$ be a surjection.  Lift $f$ to events by pointwise application; and
then lift $f$ to traces by pointwise application.  We will prove the following
results, subject to reasonably mild restrictions on the use
of~|T|.\footnote{The notation $f\inverse \banana{X}$ represents the relational
inverse image of~$X$ under~$f$, i.e.~$\set{y \| f(y) \in X}$.}
%
\begin{eqnarray}
\traces(P[T_2]) & = & \set{f(tr) \| tr \in \traces(P[T_1])},
  \label{eqn:traces} \\
\failures(P[T_2]) & = &
  \set{(f(tr), X) \| (tr, f\inverse \banana{X}) \in \failures(P[T_1])},
  \label{eqn:failures} \\
\divergences(P[T_2]) & = & \set{f(tr) \| tr \in \divergences(P[T_1])}.
\label{eqn:fd}
\end{eqnarray}

%%%%%


We will prove a more general result.  Let $E$ be an expression in the script
(either representing a process or a non-process value), with values $E[T_1]$
and $E[T_2]$ when interpreted with respect to the two types.  Then we will
show $f(E[T_1]) = E[T_2]$, for a suitably lifted definition of~$f$.



Main restrictions: no equality tests; no use of values from the type. 

Related work

Contributions/roadmap.
