\section{Evaluation}

We assume a well-typed script.


\subsection{Values}

We begin by defining the set of values associated with expressions in a
script.  The set $Value$ contains the union of the following. 
%
\begin{itemize}
\item Basic values: integers, booleans, and characters.

\item Datatype constructors and channel names.

\item Dotted tuples $v_1.\ldots.v_n$: in such values, we assume each
  component~$v_i$ is not a dotted term; i.e.~we treat the dot operator as
  associative, and ``flatten'' nested dots.  We sometimes write $\varepsilon$
  for the empty dotted tuple, i.e.~the unit of dot.

\item Sequences $\seq{v_1,\ldots,v_n}$, sets
  $\set{v_1,\ldots,v_n}$, tuples $(v_1,\ldots,v_n)$ and mappings
  $\set{v_1 \mapsto v_1', \ldots, v_n \mapsto v_n'}$, where each $v_i, v_i'$
  is a value.

\item Functions, considered as sets of maplets ($v \mapsto v'$); we sometimes
  represent functions using lambda abstractions.

\item Augmented labelled transition systems (defined below), representing
  processes.

\item For each channel declaration $\CSPMM{channel}~c : e_1\M.\ldots\M.e_n$, a
  channel value $\channel S$, where $S$ is the set of values that can be
  passed on~$c$, i.e.~all values of the form $v_1.\ldots.v_n$ associated with
  $e_1.\ldots.e_n$.  In the case $n=0$, we use the value
  $\channel \set\varepsilon$.  

\item For each datatype declaration
\[
\CSPMM{datatype}~D = 
  A_1.e_{1,1}.\ldots.e_{1,m_1} \mid \ldots \mid A_n.e_{n,1}.\ldots.e_{n,m_n}
\]
datatype constructor values $\dtcons S_i$ corresponding to~$A_i$, for
$i = 1,\ldots,n$, where $S_i$ is the set of values of the form
$v_1.\ldots.v_{m_i}$ associated with $e_{i,1}.\ldots.e_{i,m_i}$.  In the case
$m_i=0$, we use the value $\dtcons\set\varepsilon$.

\item Distinguished values $\error$ representing an error, and $\bottom$
  representing a non-terminating computation.
\end{itemize}

For later convenience, we define the semantics of processes in terms of
\emph{augmented labelled transition systems (ALTS)}.  An ALTS is a labelled
transition system, where each state is an element of $(Proc, Env)$, i.e.~a
\CSPm\ syntactic process expression (maybe with free variables) and an
environment giving values to (at least) the free variables.  For example,
three successive states of a process might be
\[
\begin{array}{rl}
(\M{in?x -> in?y -> c2.x.y -> STOP}, & \rho_1) \\
(\M{in?y -> c2.x.y -> STOP}, & \rho_1 \oplus \set{\M{x} \mapsto v_1}) \\
(\M{c2.x.y -> STOP}, & \rho_1 \oplus \set{\M x \mapsto v_1, \M y \mapsto v_2}),
\end{array}
\]
where $\rho_1$ is the environment corresponding to top-level declarations, for
example declarations of channels.  For a process expression~$P$, the value
$\eval \rho~P$ is an ALTS with initial state $(P,\rho)$.  For simplicity, we
assume that different identifiers (e.g.~in different parallel components) have
distinct names: this can be achieved via an alpha-renaming.

We define a standard partial order~$\sqsubseteq$ over $Value$, with bottom
element~$\bottom$, and such that all the datatype constructors are continuous.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Lifting $f$}

Let $f : T_1 \fun T_2$.  We extend $f$ to other
values in the obvious way.
\begin{itemize}
\item For values~$x$ not depending on~$t$ we have $f(x) = x$: this includes
  basic values (e.g.~integers and booleans), names of channels, names of
  datatype constructors other than those in~$T_1$, and the distinguished values
  $\varepsilon$, $\bottom$ and $\error$.

\item We lift $f$ to dotted tuples, including events, by point-wise
  application: $f(v_1.\ldots.v_n) = f(v_1).\ldots.f(v_n)$.  This is well
  defined provided \framebox{???} (see below).

\item We lift $f$ to tuples, sets, sequences and maps by point-wise
  application.

\item \framebox{maps}

\item For channel and datatype constructor values we define
  $f(\channel S) = \channel (f(S))$, and
  $f(\dtcons S) = \dtcons (f(S))$.

\item We lift $f$ to functions, considered as sets of maplets, by pointwise
  application: $f (g) = \set{ f(x) \mapsto f(y) \mid x \mapsto y \in g }$.

\item We lift $f$ to environments as for other functions, i.e.~$f(\rho) =
  \set{f(x) \mapsto f(y) \| x \mapsto y \in \rho}$.  Note that for all
  names~$x$ other than elements of the distinguished type, $f(x) = x$.  When
  applied to names from the distinguished type, each mapping $x \mapsto
  \dtcons\set\epsilon$ is replaced by $f(x) \mapsto \dtcons\set\epsilon$.

%% For convenience, we lift $f$ to environments by functional
%%   composition, i.e.~$f(\rho) = f\after\rho$.

\item We lift $f$ to ALTS states by point-wise application, so $f(Q,\rho) =
  (Q, f\after\rho)$. 

\item We lift $f$ to ALTSs by application of~$f$ to the states and to the
  events of the transitions.  Note that, as $f$ is not necessarily injective,
  this might merge some states.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Semantics}

We use an \emph{environment} mapping identifiers (variables) to values:
\[
Env = Var \pfun Value.
\]
We write $\rho$, $\rho'$, etc., for environments.  An environment can
associate top-level names with values, for example corresponding to the
declaration of channels.  If $c$ is the name of a channel, we will sometimes
write $v \in \rho(c)$ to mean $v \in S$ where $\rho(c) = \channel S$.
In addition, an environment can give the value of, for example:
%
\begin{itemize}
\item a name that corresponds to a formal parameter of a function;
\item a name bound by a ``|let| \ldots |within|'' clause;
\item a name bound by an input or nondeterministic choice in a process;
\item a name for an indexing variable in an indexed process operator;
\item a name bound by a generator in a set comprehension.
\end{itemize}

\CSPm\ uses the following syntactic categories.
%
\begin{itemize}
\item The type $Expr$ represents \CSPm\ expressions, both process expressions
  and non-process expressions.

\item The type $Pat$ represents a pattern used in pattern matching, including
  constant patterns (e.g.~|3|), variable patterns (e.g.~|x|), wildcard
  patterns (\CSPM{\_}), tuple patterns (e.g.~|(3,x)|), dotted patterns
  (e.g.~\CSPM{3.x.\_}), set patterns (e.g.~\CSPM{\{x\}}, sequence patterns
  (e.g.~|<x> ^ xs|), and double patterns~(e.g.~\CSPM{pair @@ (x,y)}.

\item The type |Decl| represents a declaration (e.g. |P = STOP|,\, \CSPM{f(x) =
  x+1},\, \CSPM{datatype T1 = A \| B}, or |channel c: T1|.

\item The type |Stmt| represents statements in set or sequence comprehensions,
  either generators (e.g.~|x <- xs|), or predicates (e.g.~|x < 3|).
\end{itemize}

%% The semantics of expressions is
%% defined using a function $\eval : Env \fun Expr \pfun Value$ such that
%% $\eval \rho~e$ gives the value of expression~$e$ in environment~$\rho$.

The semantics is defined using the following functions:
%
\begin{itemize}
\item $\eval : Env \fun Expr \pfun Value$ such that $\eval \rho~e$ gives the
  value of expression~$e$ in environment~$\rho$.

\item $\matches : Env \fun Pat \fun Value \fun Bool$ such that
  $\matches \rho~pat ~ v$ tests whether pattern~$pat$ can be matched by
  value~$v$.

\item $\bind_0, \bind : Env \fun Pat \fun Value \pfun Env$ such that
  $\bind_0 \rho~pat~v$ gives the updates to the environment by binding
  pattern~$pat$ to value~$v$, and is defined when $\matches \rho~ pat~v$; and 
  $\bind \rho~pat~v$ gives the result of those updates, i.e.
  \begin{eqnarray*}
  \bind \rho~pat~v & = & \rho \oplus \bind_0 \rho~pat~v.
  \end{eqnarray*}
% Do we need $\rho$ for $bind_0$?  Yes, we do: we need to know whether an
% identifier represents a datatype constructor or a channel. 

\item $\bindDecl : Env \fun Decl \pfun Env$ such that $\bindDecl \rho~decl$,
  gives the update to the environment corresponding to the
  declaration~$decls$.  And $\bindDecls : Env \fun Decl^* \pfun Env$ such that
  $\bindDecls \rho~decls$, updates $\rho$ corresponding to the list of
  declarations $decls$, assuming that all names bound by the declarations are
  distinct, and that each pattern matches the corresponding expression; the
  declarations might be mutually recursive, so the semantics is defined as a
  least fixed point:
  \[
  \begin{align}
  \bindDecls \rho~decls = \bigsqcup_{n \in \nat} F^n(\rho) \\
  \mbox{where } F(\rho_1)  =  
    \rho_1 \oplus \Union \set{\bindDecl \rho_1 ~ decl \| decl \in decls}.
  \end{align}
  \]

\item $\evalStmts : Env \fun Stmt^* \fun Env^*$ such that $\evalStmts
  \rho~stmts$ gives the sequence of environments resulting from evaluating the
  statements~$stmts$.  (In some circumstances, this sequence of environments
  is converted into a multiset; we elide this conversion below.)

\item $\evalStmtsSet : Env \fun Stmt^* \fun \power(Env)$ such that
  $\evalStmtsSet \rho~stmts$ gives the set of environments resulting from
  evaluating the statements~$stmts$.
\end{itemize}

